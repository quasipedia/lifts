#! /usr/bin/env python3
'''
A Lift simulator.
'''
from copy import deepcopy
from time import time, sleep
from random import choice, gauss

#import toml

from log import log
from person import Person
from floor import Floor
from lift import Lift
from interface import FileInterface
from enums import LiftStatus, PersonStatus, Command, Message


DEFAULT = {
    'id': 'default',
    'building': [
        {'level': 3, 'is_exit': False, 'is_entry': False},
        {'level': 2, 'is_exit': False, 'is_entry': False},
        {'level': 1, 'is_exit': False, 'is_entry': False},
        {'level': 0, 'is_exit': True, 'is_entry': True},
    ],
    'lifts': [
        {'name': 'main', 'capacity': 4, 'directional': True,
         'pass_sec': 3, 'accel_sec': 6},
    ],
    'simulation': {
        'duration_min': 5,
        'population': 5
    }
}
TIME_COMPRESSION = 1  # 360 --> 1h = 10sec
GRANULARITY = 1  # in real seconds
POST_END_GRACE_PERIOD = 60  # in seconds
CLIENT_BOOT_GRACE_PERIOD = 10  # in seconds


class Simulation:

    def __init__(self, description, interface):
        self.description = self._time_compress(description)
        self.interface = interface
        self.step_counter = 0
        self._init_floors()
        self._init_lifts()
        self._init_people()

    def _time_compress(self, description):
        ret = deepcopy(description)
        for lift in ret['lifts']:
            for k, v in lift.items():
                lift[k] = v / TIME_COMPRESSION if k.endswith('_sec') else v
        ret['simulation']['duration_min'] *= 60 / TIME_COMPRESSION
        return ret

    def _init_floors(self):
        '''Set and return the initial state for all floors.'''
        self.floors = {}
        for floor_description in reversed(self.description['building']):
            floor = Floor(self, floor_description)
            self.floors[floor.level] = floor
        self.entries = [f for f in self.floors.values() if f.is_entry]
        self.exits = [f for f in self.floors.values() if f.is_exit]

    def _init_lifts(self):
        '''Set and return the initial state for all lifts.'''
        self.lifts = {}
        for description in self.description['lifts']:
            floor = choice(list(self.floors.values()))
            lift = Lift(self, description, LiftStatus.open, floor)
            self.lifts[lift.name] = lift

    def _init_people(self):
        '''Set and return the initial state for all people.'''
        self.people = []
        duration = self.description['simulation']['duration_min']
        for pid in range(self.description['simulation']['population']):
            event_time = max(0, gauss(duration / 2, duration / 6))
            pid_string = '#{0:05d}'.format(pid)
            destination = choice(list(self.floors.values()))
            self.people.append(Person(self, pid_string, PersonStatus.idle,
                                      None, destination, event_time))

    def route(self, event, entity=None, *args):
        '''Listen to events generated by the objects in the game.'''
        msg = 'Routing "{} --> {}"[payload: {}]'
        log.debug(msg, event, entity, args)
        if event in Message:
            self.interface.send_message(event, entity, *args)
        elif event in Command:
            try:
                self.lifts[entity].move(event, entity, *args)
            except KeyError:
                msg = 'There is no lift called "{}"'.format(entity)
                self.route(Message.error, self, msg)
        else:
            log.error('Unknown event: "{}"'.format(event))

    def step(self):
        '''Run a single step of the simulation.'''
        self.step_counter += 1
        self.route(Message.turn, None, self.step_counter)
        elapsed = time() - self.start_time
        log.debug('Step {} ({:.3f} s)', self.step_counter, elapsed)
        for command, entity, floor in self.interface.get_commands():
            self.route(command, entity, floor)
        for person in self.people:
            person.step(elapsed)
        intended_duration = self.start_time + GRANULARITY * self.step_counter
        sleep_duration = max(intended_duration - time(), 0)
        sleep(sleep_duration)

    def check_client_is_ready(self):
        '''Return True if the client AI is ready to play.'''
        start_waiting_time = time()
        while time() < start_waiting_time + CLIENT_BOOT_GRACE_PERIOD:
            if False:  # Change with real test
                yield True
            yield False

    def run(self):
        '''Run the simulation.'''
        log.debug('Waiting for the AI client to signal their readiness.')
        checker = self.check_client_is_ready()
        try:
            while not next(checker):
                sleep(0.5)
        except StopIteration:
            log.critical('The client never sent the READY signal.')
            exit(1)
        log.info('Simulation started')
        # Set time limits and utility functions
        duration = self.description['simulation']['duration_min']
        self.start_time = time()
        hard_limit = self.start_time + duration + POST_END_GRACE_PERIOD
        overdue = lambda: time() > hard_limit
        done = lambda: all(p.status == PersonStatus.done for p in self.people)
        # Run the main loop
        while not done():
            if overdue():
                log.error('Hard time limit hit')
                break
            self.step()
        # Post-simulation operations
        elapsed = time() - self.start_time
        self.route(Message.ended)
        log.info('Simulation ended, total duration: {:.3f} seconds', elapsed)


def main():
    interface = FileInterface('/tmp/lifts')
    simulation = Simulation(DEFAULT, interface)
    simulation.run()


if __name__ == '__main__':
    main()
